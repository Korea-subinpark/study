# Node.js
## 특징
* 서버
    * 서버 애플리케이션을 실행하는데 가장 많이 사용된다
* 런타임
    * JavaScript를 브라우저가 아닌 컴퓨터에서 실행할 수 있게 해준다
* 이벤트 기반
    * 이벤트가 발생하면 콜백 함수를 호출한다
    * 이벤트가 없거나 모두 처리된 상태면 다음 이벤트가 발생할 때까지 기다린다
    * 이벤트 loop
        * 이벤트 발생 시 호출할 콜백 함수들을 관리
        * 호출된 콜백 함수의 실행 순서 결정
        * 노드가 종료될 때까지 이벤트 처리 작업 반복
    * task 큐(콜백 큐)
        * 이벤트 발생 후 호출되어야 할 콜백 함수들이 저장된 큐
    * 백그라운드
        * 타이머, I/O 콜백 또는 이벤트 리스너들이 대기하는 곳
* 논블로킹 I/O
    * 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되도록 한다
    * 백그라운드로 보내진 함수는 task 큐를 거쳐 다시 호출 스택으로 올라온다
    ```javascript
    function longRunningTask() {
        console.log('작업 끝');
    }
    console.log('시작');
    setTimeout(longRunningTask, 0);//오래 걸리는 작업을 백그라운드로 보낸다
    //실제로는 setTimeout보다 setImmediate을 많이 사용
    console.log('다음 작업');
    //결과
    //시작
    //다음 작업
    //작업 끝
    ```
* 싱글 스레드
    * 노드 프로세스에 여러 개의 스레드가 있지만 직접 제어할 수 있는 스레드는 하나이다
    * 장점: 스레드를 추가하거나 놀고 있는 스레드를 삭제하는 비용이 없다

## 노드 서버의 장단점
|장점|단점|
|---|---|
|멀티 스레드 방식에 비하여 자원을 적게 사용|CPU 코어를 하나밖에 사용하지 못함|
|libuv 라이브러리로 I/O 작업을 논블로킹으로 처리|싱글 스레드이기 때문에 에러 처리가 안되면 서버 전체가 멈춤|
|웹 서버가 내장|서버 규모가 커지면 관리가 어려움|
|JavaScript를 사용하기 때문에 JSON 형식을 다루기 쉬움|CPU 연산이 많으면 블로킹이 발생해 비효율적|
||이미지나 비디오 처리, 대규모 데이터 처리에는 부적합|

## Node 내장 객체
* global
    * 브라우저의 window와 같은 전역 객체
    * 모든 파일에서 접근 가능
    * 프로젝트 규모가 커지면 어떤 파일에서 수정했는지 알 수 없기 때문에 남용하지 않아야 한다
* console
    * 주로 디버깅에 사용
    * 시간 측정 `colsole.time`, `console.timeEnd`
    * 콘솔 출력 `console.log`
    * 에러 출력 `console.error`
* 타이머
    * `setImmediate(콜백 함수)` : 콜백 함수를 즉시 실행
    * `setInterval(콜백 함수, 밀리초)` : 주어진 밀리초마다 콜백 함수를 반복 실행
* `__filename`, `__dirname`
    * 파일과 디렉토리 경로를 알아낼 때 사용
* process
    * 현재 실행되고 있는 노드 프로세스에 대한 정보를 가지고 있다
    * `process.env` : 서비스의 중요한 키를 저장 (`SECRET_ID`, `SECRET_CODE`)
    * `process.nextTick(콜백 함수)` : 다른 콜백 함수들보다 우선으로 처리 (`promise`도 다른 콜백보다 우선 처리 된다), nextTick과 promise를 `Microtask`라고 부른다
    * `Microtask`를 재귀 호출 하게 되면 다른 콜백 함수들이 실행되지 않을 수도 있다
    * `process.exit()` : 실행 중인 노드 프로세스 종료, 서버에는 거의 사용하지 않는다
